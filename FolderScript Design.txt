a[]		argument	a[0]
#var	variable	#tal = 50 ^names can only contain alphanumeric characters and '_'^
#var[]	array		#file[#numb] = "path"

?(){:}	conditional	?(a[1] = ""){^do stuff^:^do other stuff^}
i0(){}	iterate		i2(a[0]){^do stuff^}
b		break out
t{}		test (try)	#bool = t{c(a[0], #file)} ^Returns '0' if an error occured, '1' otherwise^
h		help		h c ^displays help text of command 'c'^
,		separator	^funtions as an input separator^
:		separator	^funtions as a true / false separator in conditionals^

@fu(){}	method def	@name(1){w(@name[0], $) ?(@name[0] > 10){@name = @name[0]+1 b : @name(@name[0])}}
@fu()	method call	#num = @name(15)

^	^	comment		c(a[0], a[1]) ^m(a[0], a[1])^

+		addition	5 + 4 = 9
-		subtraction	5 - 3 = 2
*		multiplication
/		division
%		modulo		5 % 2 = 1

<		less		#test = 10 < 5 ^ #test returns as 0 (false) ^
>		greater
!		negate		?(!f([0])){^do stuff^}
=		equal
&		and
|		or

0		0 or false
1		1 or true
$		special
"	"	mark as text	^Escape characters: tab (\t), return (\r, \n), command bracket (\{, \}), quotation mark (\"), apostrophe (\'), backslash (\\)^
"{ }"	mark as regex
.0		environment	#path=.0 ^Returns environment variables. 0: current execution directory, 1: temp folder location, 2: log file location, 3: system time, 4: date time^
'0		attribute	#hidden=#file'0 ^Returns environment variables. 0: is hidden, 1: is link, 2: last modified, 3: last accessed, 4: creation time^

n()		name
e()		extension	e(a[0])
p()		parent		p(a[0]) ^Returns the parent folder of the first argument^
f()		is file		f(a[0]) 
v()		is available

c(,)	copy		c(a[0], #path)
m(,)	move		^Doubles as a rename funtion^
d()		delete
l(,)	list		l(a[0], 3) ^Functions as sorting for array variables. Second input is how to sort the array; 0: by variable type and size (utilizing s() function), 1: by alpha-numeric value^
w(,)	write		w("Text to add", a[0])
r()		read		#text = r(a[0])
g()		gen MD5		g(a[0])

s()		size		s(l(a[0], $)) ^if you do a number it will return the absolute value, fx: size(-21) will return 21^
y(,,)	replace		#var = y(a[0], "name0", #newname)
u(,,)	substring	u(#text, #from, #to)
q()		random		q(5) ^Gives either a random whole number between 0 and the input number, a random item of a given array, a random file or folder in a given folder, or a random letter in a given piece of text^

z()		sleep		z(1000) ^sleeps for 1 second^
x()		exit		x(0)
o(,)	options		o(0,1) ^Changes an option in the options table. 0 is debug mode, 1 is overwrite allowed, 2 list on folders return only sub-folders instead of mix, 3 restrict arrays to only one type of data, 4 routes external log into program^
k(,)	external	k(a[0],#args) ^Runs an external program or script.^


Available letters:
j

Available symbols:
;ยง 

Ideas pool:
- Zipping and unzipping (Should take j as it is a proper command)
- Ability to 'bridge' between script, that is run scripts from within script and access internal variables at that end. (Abandoned as it gives too many potential problems compared to the few solutions it gives. Possible just give k(,) an '$' option for the first argument, which would be 'run FolderScript internally'; use 'System.getProperty("sun.java.command")' to get executing file)
- Accessing file metadata; https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html (Should take ' as it is a special feature akind more akind to environment variables than to methods; "C:/folder/file.mp3"'4 i0'1 #file'0)
Example:

w("Hallo World!", $)
^ Classic Hallo World! program^

i0(100){?(i0 % 15 = 0){w("FizzBuzz",$):?(i0 % 3 = 0){w("Fizz",$): ?(i0 % 5 = 0){w("Buzz", $):w(i0, $)}}}}
^ Simple implementation of FizzBuzz program. ^

i0(l(a[0],$)){?(n(i0)=a[1]){d(i0)}}
^ iterates through files in the first argument and all subdirectories and if the file's name is equal to the second argument, the file is deleted.^

i0(l(a[0],0)){w(i0+"\r",a[1]),w(i0+"\r",$)}
^ lists all files in a folder given by the first argument and writes it to a file given by the second argument and outputs the file to the console.^